<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tutorials on Flutter Data</title><link>/tutorial/</link><description>Recent content in Tutorials on Flutter Data</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="/tutorial/index.xml" rel="self" type="application/rss+xml"/><item><title>Fetching tasks</title><link>/tutorial/fetching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/fetching/</guid><description>Before you continue:
Make sure you went through the Quickstart and got Flutter Data up and running!
Also, you can check out the full source code for this tutorial at https://github.com/flutterdata/tutorial
We now have access to our Repository&amp;lt;Task&amp;gt; through ref.tasks, with an API base URL set to https://my-json-server.typicode.com/flutterdata/demo/.
Inspecting the /tasks endpoint we see:
[ { &amp;#34;id&amp;#34;: 1, &amp;#34;title&amp;#34;: &amp;#34;Laundry ðŸ§º&amp;#34;, &amp;#34;completed&amp;#34;: false, &amp;#34;userId&amp;#34;: 1 }, { &amp;#34;id&amp;#34;: 2, &amp;#34;title&amp;#34;: &amp;#34;Groceries ðŸ›’&amp;#34;, &amp;#34;completed&amp;#34;: true, &amp;#34;userId&amp;#34;: 1 }, { &amp;#34;id&amp;#34;: 3, &amp;#34;title&amp;#34;: &amp;#34;Reservation at Malloys&amp;#34;, &amp;#34;completed&amp;#34;: true, &amp;#34;userId&amp;#34;: 1 }, // .</description></item><item><title>Marking tasks as done</title><link>/tutorial/updating/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/updating/</guid><description>A read-only tasks app is not very practical! Let&amp;rsquo;s add the ability to update the completed state and mark/unmark our tasks as done.
First, though, we&amp;rsquo;ll extract the tasks-specific code to a separate screen named TasksScreen:
class TasksScreen extends HookConsumerWidget { @override Widget build(BuildContext context, WidgetRef ref) { final state = ref.tasks.watchAll(); if (state.isLoading) { return CircularProgressIndicator(); } return ListView( children: [ for (final task in state.model!) Text(task.title), ], ); } } Remember to return this new widget from TasksApp:</description></item><item><title>Creating a new task</title><link>/tutorial/creating/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/creating/</guid><description>First off let&amp;rsquo;s add just one line during the initialization. This will enable very helpful logging of our tasks repository!
// ... child: ref.watch(repositoryInitializerProvider).when( error: (error, _) =&amp;gt; Text(error.toString()), loading: () =&amp;gt; const CircularProgressIndicator(), data: (_) { // enable verbose ref.tasks.logLevel = 2; return TasksScreen(); } ), // ... When we restart we notice the following:
flutter: 34:061 [watchAll/tasks@e20025] initializing flutter: 34:100 [findAll/tasks@e2046b&amp;lt;e20025] requesting [HTTP GET] https://my-json-server.typicode.com/flutterdata/demo/tasks flutter: 34:835 [findAll/tasks@e2046b&amp;lt;e20025] {1, 2, 3, 4, 5} (and 5 more) fetched from remote Let&amp;rsquo;s add a TextField, turn the input into a new Task and immediately save it.</description></item><item><title>Reloading the list</title><link>/tutorial/reloading/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/reloading/</guid><description>Let&amp;rsquo;s make the number of tasks more manageable via the _limit server query param, which in this case will return a maximum of 5 resources.
class TasksScreen extends HookConsumerWidget { @override Widget build(BuildContext context, WidgetRef ref) { final state = ref.tasks.watchAll(params: {&amp;#39;_limit&amp;#39;: 5}); // ... } Hot restarting the app we should only see five tasks, but&amp;hellip;
It&amp;rsquo;s exactly the same as before. Why isn&amp;rsquo;t this working? ðŸ¤”
Turns out watchAll is wired to show all tasks in local storage.</description></item><item><title>Deleting tasks</title><link>/tutorial/deleting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/deleting/</guid><description>There&amp;rsquo;s stuff we just don&amp;rsquo;t want to do!
We can delete a Task on dismiss by wrapping the tile with a Dismissible and calling its delete method:
class TasksScreen extends HookConsumerWidget { @override Widget build(BuildContext context, WidgetRef ref) { final _newTaskController = useTextEditingController(); final state = ref.tasks.watchAll(params: {&amp;#39;_limit&amp;#39;: 5}, syncLocal: true); if (state.isLoading) { return CircularProgressIndicator(); } return RefreshIndicator( onRefresh: () =&amp;gt; ref.tasks.findAll(params: {&amp;#39;_limit&amp;#39;: 5}, syncLocal: true), child: ListView( children: [ TextField( controller: _newTaskController, onSubmitted: (value) async { Task(title: value).</description></item><item><title>Using relationships</title><link>/tutorial/relationships/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/relationships/</guid><description>Let&amp;rsquo;s now slightly rethink our query. Instead of &amp;ldquo;fetching all tasks for user 1&amp;rdquo; we are going to &amp;ldquo;fetch user 1 with all their tasks&amp;rdquo;.
Flutter Data has first-class support for relationships.
First, in models/user.dart, we&amp;rsquo;ll create the User model with a HasMany&amp;lt;Task&amp;gt; relationship:
import &amp;#39;package:flutter_data/flutter_data.dart&amp;#39;; import &amp;#39;package:json_annotation/json_annotation.dart&amp;#39;; import &amp;#39;task.dart&amp;#39;; part &amp;#39;user.g.dart&amp;#39;; @JsonSerializable() @DataRepository([JsonServerAdapter]) class User extends DataModel&amp;lt;User&amp;gt; { @override final int? id; final String name; final HasMany&amp;lt;Task&amp;gt; tasks; User({this.id, required this.</description></item></channel></rss>