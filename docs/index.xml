<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docs on Flutter Data</title>
    <link>/docs/</link>
    <description>Recent content in Docs on Flutter Data</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 20 Apr 2020 19:01:08 -0300</lastBuildDate><atom:link href="/docs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Quickstart</title>
      <link>/docs/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/quickstart/</guid>
      <description>Add flutter_data and dependencies to your pubspec.yaml file:
dependencies:flutter:sdk:flutterflutter_data:^1.0.0# Highly RECOMMENDED (but not required) packagespath_provider:^2.0.7json_annotation:4.3.0flutter_riverpod:^1.0.0dev_dependencies:build_runner:^1.10.1# REQUIRED! Please use versions &amp;gt;= 1.10.1# Highly RECOMMENDED (but not required) packagesjson_serializable:^6.0.1Flutter Data doesn&amp;rsquo;t require any library besides build_runner for code generation.
However, json_serializable and path_provider are highly convenient so they are recommended.
The latest flutter_data should be 1.0.0. Please check for all packages latest stable versions before copy-pasting dependencies.  Basic configuration ðŸ”§ Annotate your models with @DataRepository() and mix DataModel&amp;lt;T&amp;gt; in.</description>
    </item>
    
    <item>
      <title>Repositories</title>
      <link>/docs/repositories/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/repositories/</guid>
      <description>Flutter Data is organized around the concept of models which are data classes mixing in DataModel.
@DataRepository([TaskAdapter]) class Task with DataModel&amp;lt;Task&amp;gt; { @override final int? id; final String title; final bool completed; Task({this.id, required this.title, this.completed = false}); // ... } When annotated with @DataRepository (and adapters as arguments, as we&amp;rsquo;ll see later) a model gets its own fully-fledged repository. Repository is the API used to interact with models â€“ whether they are local or remote.</description>
    </item>
    
    <item>
      <title>Adapters</title>
      <link>/docs/adapters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/adapters/</guid>
      <description>Flutter Data is extremely customizable and composable thanks to adapters, Flutter Data&amp;rsquo;s building blocks.
Adapters are essentially Dart mixins applied on RemoteAdapter&amp;lt;T&amp;gt;.
Overriding basic behavior Several parts are required, for example, to construct a remote findAll call on a Repository&amp;lt;Task&amp;gt;. The framework can take a sensible guess and make that GET /tasks by default â€“ and it does.
Still, a base URL is necessary and the endpoint parts should be overridable.</description>
    </item>
    
    <item>
      <title>Models</title>
      <link>/docs/models/</link>
      <pubDate>Mon, 20 Apr 2020 19:01:08 -0300</pubDate>
      
      <guid>/docs/models/</guid>
      <description>Flutter Data models are data classes that mix DataModel in:
@DataRepository([TaskAdapter]) @JsonSerializable() class Task with DataModel&amp;lt;Task&amp;gt; {  @override final int? id; final String title; final bool completed; Task({this.id, required this.title, this.completed = false}); } This enforces the implementation of the id getter. Use the type that better suits your data: int? and String? are the most common.
The json_serializable library is helpful but not required.
 Model with @JsonSerializable? You don&amp;rsquo;t need to declare fromJson or toJson Model without @JsonSerializable?</description>
    </item>
    
    <item>
      <title>Relationships</title>
      <link>/docs/relationships/</link>
      <pubDate>Mon, 20 Apr 2020 17:21:33 -0300</pubDate>
      
      <guid>/docs/relationships/</guid>
      <description>Flutter Data features an advanced relationship mapping system.
Use:
 HasMany&amp;lt;T&amp;gt; for to-many relationships BelongsTo&amp;lt;T&amp;gt; for to-one relationships  As an example, a User has many Tasks:
@JsonSerializable() @DataRepository([JSONServerAdapter]) class User with DataModel&amp;lt;User&amp;gt; { @override final int? id; final String name; final HasMany&amp;lt;Task&amp;gt;? tasks;  User({this.id, required this.name, this.tasks}); } and a Task belongs to a User:
@JsonSerializable() @DataRepository([JSONServerAdapter]) class Task with DataModel&amp;lt;Task&amp;gt; { @override final int? id; final String title; final bool completed; final BelongsTo&amp;lt;User&amp;gt;?</description>
    </item>
    
    <item>
      <title>Initialization</title>
      <link>/docs/initialization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/initialization/</guid>
      <description>In Flutter with Riverpod The setup involves two parts: setting up local storage via configureRepositoryLocalStorage, and then waiting for Flutter Data initialization in the entry point widget.
import &amp;#39;package:flutter/material.dart&amp;#39;; import &amp;#39;package:hooks_riverpod/hooks_riverpod.dart&amp;#39;; import &amp;#39;package:flutter_data/flutter_data.dart&amp;#39;;  import &amp;#39;main.data.dart&amp;#39;; import &amp;#39;models/task.dart&amp;#39;;  void main() { runApp( ProviderScope( child: MyApp(), overrides: [configureRepositoryLocalStorage()],  ), ); } class MyApp extends HookConsumerWidget { @override Widget build(BuildContext context, WidgetRef ref) { return MaterialApp( home: Scaffold( body: Center( child: ref.</description>
    </item>
    
    <item>
      <title>FAQ</title>
      <link>/docs/faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/faq/</guid>
      <description>Why are save and other methods not available on my models? DataModel extensions are syntax sugar and will only work when importing Flutter Data:
import &amp;#39;package:flutter_data/flutter_data.dart&amp;#39;; Errors generating code? If you have trouble with the outputs, try:
flutter pub run build_runner build --delete-conflicting-outputs VSCode users!
If after generating code you still see errors in your files, try reopening the project. This is not a Flutter Data issue.
 Also make sure your dependencies are up to date:</description>
    </item>
    
  </channel>
</rss>
