<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docs on Flutter Data</title><link>/docs/</link><description>Recent content in Docs on Flutter Data</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 20 Apr 2020 19:01:08 -0300</lastBuildDate><atom:link href="/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Quickstart</title><link>/docs/quickstart/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/quickstart/</guid><description>Add flutter_data and dependencies to your pubspec.yaml file:
dependencies: flutter: sdk: flutter flutter_data: ^1.5.6 # Highly RECOMMENDED (but not required) packages path_provider: ^2.0.11 json_annotation: ^4.7.0 hooks_riverpod: ^2.1.1 dev_dependencies: build_runner: ^2.2.0 # REQUIRED! # Highly RECOMMENDED (but not required) packages json_serializable: ^6.4.1 Flutter Data doesn&amp;rsquo;t require any library besides build_runner for code generation.
However, json_serializable and path_provider are very convenient so they are recommended.
The latest flutter_data should be 1.5.6. Please check for all packages latest stable versions before copy-pasting dependencies.</description></item><item><title>Repositories</title><link>/docs/repositories/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/repositories/</guid><description>Flutter Data is organized around the concept of models which are data classes extending DataModel.
@DataRepository([TaskAdapter]) class Task extends DataModel&amp;lt;Task&amp;gt; { @override final int? id; final String title; final bool completed; Task({this.id, required this.title, this.completed = false}); // ... } When annotated with @DataRepository (and adapters as arguments, as we&amp;rsquo;ll see later) a model gets its own fully-fledged repository.
Repository is the API used to interact with models, whether local or remote.</description></item><item><title>Adapters</title><link>/docs/adapters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/adapters/</guid><description>Flutter Data&amp;rsquo;s building blocks are called adapters, making it extremely customizable and composable.
Adapters are essentially Dart mixins applied on RemoteAdapter&amp;lt;T&amp;gt;.
Overriding basic behavior Several pieces of information are required, for example, to construct a remote findAll call on a Repository&amp;lt;Task&amp;gt;. The framework takes a sensible guess and makes that GET /tasks by default.
Still, a base URL is necessary and the endpoint parts should be overridable.
The way we use these adapters is by declaring them on our @DataRepository annotation in the corresponding model.</description></item><item><title>Local Adapters</title><link>/docs/local-adapters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/local-adapters/</guid><description>Local adapters access the local storage, which for now is only Hive.
It is extremely rare to have to override a local adapter, so use with caution if you do.
A particularly useful use-case is data migration as LocalAdapter&amp;rsquo;s deserialize will be called after loading raw data from the Hive box and before the json_serializable call.
Example:
mixin TaskLocalAdapter on LocalAdapter&amp;lt;Task&amp;gt; { @override Task deserialize(Map&amp;lt;String, dynamic&amp;gt; map) { // transform map from old format to new format } } Activate the use of the overridden adapter with:</description></item><item><title>Models</title><link>/docs/models/</link><pubDate>Mon, 20 Apr 2020 19:01:08 -0300</pubDate><guid>/docs/models/</guid><description>Flutter Data models are data classes that extend DataModel and are annotated with @DataRepository:
@DataRepository([TaskAdapter]) @JsonSerializable() class Task extends DataModel&amp;lt;Task&amp;gt; { @override final int? id; final String title; final bool completed; Task({this.id, required this.title, this.completed = false}); } DataModel automatically registers new data classes within the framework and enforces the implementation of an id getter. Use the type that better suits you: int? and String? are the most common.
The json_serializable library is helpful but not required.</description></item><item><title>Relationships</title><link>/docs/relationships/</link><pubDate>Mon, 20 Apr 2020 17:21:33 -0300</pubDate><guid>/docs/relationships/</guid><description>Flutter Data features an advanced relationship mapping system.
Use:
HasMany&amp;lt;T&amp;gt; for to-many relationships BelongsTo&amp;lt;T&amp;gt; for to-one relationships As an example, a User has many Tasks:
@JsonSerializable() @DataRepository([JsonServerAdapter]) class User extends DataModel&amp;lt;User&amp;gt; { @override final int? id; final String name; final HasMany&amp;lt;Task&amp;gt;? tasks; User({this.id, required this.name, this.tasks}); } and a Task belongs to a User:
@JsonSerializable() @DataRepository([JsonServerAdapter]) class Task extends DataModel&amp;lt;Task&amp;gt; { @override final int? id; final String title; final bool completed; final BelongsTo&amp;lt;User&amp;gt;?</description></item><item><title>Offline</title><link>/docs/offline/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/offline/</guid><description>You can do this in your Scaffold
child: ref.watch(initializerProvider).when( error: (error, _) =&amp;gt; Text(error.toString()), loading: () =&amp;gt; const CircularProgressIndicator(), data: (_) =&amp;gt; Text(&amp;#39;App boot is ready, replace me with main UI widget&amp;#39;), ), ), Then define your initializer where you initialize any number of services needed to display the main widget of your UI:
final initializerProvider = FutureProvider&amp;lt;void&amp;gt;((ref) async { // initialize FD await ref.container.refresh(repositoryInitializerProvider.future); // initialize other services // retry offline events final _sub = ref.</description></item><item><title>Initialization</title><link>/docs/initialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/initialization/</guid><description>Initializing Flutter Data consists of two parts: local storage initialization and repository initialization.
The former happens when wiring up providers and the latter during widget build.
Local storage initialization Here are the configuration options with their default arguments explicit:
ProviderScope( child: MyApp(), overrides: [ configureRepositoryLocalStorage( // callback that returns a base directory where to place local storage // (if the path_provider package is present, otherwise you MUST override it) baseDirFn: () =&amp;gt; getApplicationDocumentsDirectory().</description></item><item><title>FAQ</title><link>/docs/faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/faq/</guid><description>Why are save and other methods not available on my models? DataModel extensions are syntax sugar and will only work when importing Flutter Data:
import &amp;#39;package:flutter_data/flutter_data.dart&amp;#39;; Errors generating code? If you have trouble with the outputs, try:
flutter pub run build_runner build --delete-conflicting-outputs VSCode users!
If after generating code you still see errors in your files, try reopening the project. This is not a Flutter Data issue.
Also make sure your dependencies are up to date:</description></item></channel></rss>