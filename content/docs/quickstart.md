---
title: Quickstart
menu: docs
weight: 1
---

Add `flutter_data` and dependencies to your `pubspec.yaml` file:

```yaml {hl_lines=[5 13]}
dependencies:
  flutter:
    sdk: flutter

  flutter_data: ^{{< latest >}}

  # Highly RECOMMENDED (but not required) packages
  path_provider: ^2.0.7
  json_annotation: ^4.4.0
  flutter_riverpod: ^1.0.0

dev_dependencies:
  build_runner: ^2.0.4 # REQUIRED!

  # Highly RECOMMENDED (but not required) packages
  json_serializable: ^6.1.4
```

Flutter Data doesn't require any library besides `build_runner` for code generation.

However, `json_serializable` and `path_provider` are very convenient so they are recommended.

{{< notice >}}
The latest `flutter_data` should be `{{% latest %}}`. Please check for all packages latest stable versions before copy-pasting dependencies.
{{< /notice >}}

### Basic configuration ðŸ”§

Make your models extend `DataModel<T>`, override `id` and annotate them with `@DataRepository()`.

```dart {hl_lines=[7 8]}
import 'package:flutter_data/flutter_data.dart';
import 'package:json_annotation/json_annotation.dart';

part 'task.g.dart';

@JsonSerializable()
@DataRepository([])
class Task extends DataModel<Task> {
  @override
  final int? id;
  final String title;
  final bool completed;

  Task({this.id, required this.title, this.completed = false});
}
```

`@DataRepository()` takes a list of adapters.

[Adapters](/docs/adapters) are Dart mixins used to customize the framework's behavior, ranging from the very basic to the extremely powerful. They are applied on Flutter Data's `RemoteAdapter<T>` base class.

Let's start by the most typical configuration to access a remote API, the base URL.

```dart
mixin JsonServerAdapter<T extends DataModel<T>> on RemoteAdapter<T> {
  @override
  String get baseUrl => 'https://my-json-server.typicode.com/flutterdata/demo/';
}
```

Next, we'll pass it to the annotation:

```dart {hl_lines=[2]}
@JsonSerializable()
@DataRepository([JsonServerAdapter])
class Task extends DataModel<Task> {
  final int? id;
  final String title;
  final bool completed;

  Task({this.id, required this.title, this.completed = false});
}
```

Notice two things about our model above:

- We used `int?` to represent the actual type of the `id` identifier field as it is `null` when new (it could have been a `String` too)
- The `fromJson` and `toJson` functions were skipped as they are not required (Flutter Data will automatically use `_$TaskFromJson` and `_$TaskToJson` generated by `json_serializable` â€“ but they can both be overridden)

{{< notice >}}

#### Default serialization

Flutter Data ships with a built-in serializer/deserializer for [classic JSON](https://api.rubyonrails.org/classes/ActiveModel/Serializers/JSON.html).

A `Task` instance in JSON would look like:

```json
{
  "id": 1,
  "title": "Finish this documentation for once",
  "completed": false,
  "userId": 1
}
```

{{</ notice >}}

We are now ready to run a build:

```bash
flutter pub run build_runner build
```

Flutter Data auto-generated a `Repository` class for `Task`.

It also generated a Dart library at `main.data.dart` which makes Flutter Data initialization effortless. It's out-of-the-box compatible with Riverpod.

{{< notice >}}
Trouble generating code? [See here](/docs/faq/#errors-generating-code).

Here is how to make it work with [Provider](/docs/faq/#configure-for-provider) and [GetIt](/docs/faq/#configure-for-getit).
{{< /notice >}}

Next step is to configure local storage and initialize the framework:

```dart {hl_lines=[2 3 4 10 "21-25"]}
import 'package:flutter/material.dart';
import 'package:flutter_data/flutter_data.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:tutorial/main.data.dart';

void main() {
  runApp(
    ProviderScope(
      child: TasksApp(),
      overrides: [configureRepositoryLocalStorage()],
    ),
  );
}

class TasksApp extends HookConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return MaterialApp(
      home: Scaffold(
        body: Center(
          child: ref.watch(repositoryInitializerProvider).when(
                error: (error, _) => Text(error.toString()),
                loading: () => const CircularProgressIndicator(),
                data: (_) => Text('Hello from Flutter Data ${ref.tasks}!'),
              ),
        ),
      ),
      debugShowCheckedModeBanner: false,
    );
  }
}
```

Once the `data` callback is invoked, Flutter Data is ready and the `Task` repository can be accessed via `ref.tasks`!

{{< notice >}}
The `configureRepositoryLocalStorage` setup function has several optional arguments.

If you do not have `path_provider` as a dependency you will have to supply `baseDirFn` (a function that returns a base directory for local storage).

For more information see [initialization](/docs/initialization).

Prefer a setup example? Here's the [sample setup app](https://github.com/flutterdata/flutter_data_setup_app) with support for Riverpod, Provider and get_it.
{{< /notice >}}

<strong class="bigger">âž¡ Continue with the [tutorial for a Tasks app](/tutorial) or learn more about [Repositories](/docs/repositories)</strong>
