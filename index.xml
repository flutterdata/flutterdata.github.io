<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Flutter Data</title><link>/</link><description>Recent content on Flutter Data</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 18 Dec 2021 17:08:28 -0300</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Quickstart</title><link>/docs/quickstart/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/quickstart/</guid><description>Add flutter_data and dependencies to your pubspec.yaml file:
dependencies: flutter: sdk: flutter flutter_data: ^1.5.6 # Highly RECOMMENDED (but not required) packages path_provider: ^2.0.11 json_annotation: ^4.7.0 hooks_riverpod: ^2.1.1 dev_dependencies: build_runner: ^2.2.0 # REQUIRED! # Highly RECOMMENDED (but not required) packages json_serializable: ^6.4.1 Flutter Data doesn&amp;rsquo;t require any library besides build_runner for code generation.
However, json_serializable and path_provider are very convenient so they are recommended.
The latest flutter_data should be 1.5.6. Please check for all packages latest stable versions before copy-pasting dependencies.</description></item><item><title>Fetching tasks</title><link>/tutorial/fetching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/fetching/</guid><description>Before you continue:
Make sure you went through the Quickstart and got Flutter Data up and running!
Also, you can check out the full source code for this tutorial at https://github.com/flutterdata/tutorial
We now have access to our Repository&amp;lt;Task&amp;gt; through ref.tasks, with an API base URL set to https://my-json-server.typicode.com/flutterdata/demo/.
Inspecting the /tasks endpoint we see:
[ { &amp;#34;id&amp;#34;: 1, &amp;#34;title&amp;#34;: &amp;#34;Laundry ðŸ§º&amp;#34;, &amp;#34;completed&amp;#34;: false, &amp;#34;userId&amp;#34;: 1 }, { &amp;#34;id&amp;#34;: 2, &amp;#34;title&amp;#34;: &amp;#34;Groceries ðŸ›’&amp;#34;, &amp;#34;completed&amp;#34;: true, &amp;#34;userId&amp;#34;: 1 }, { &amp;#34;id&amp;#34;: 3, &amp;#34;title&amp;#34;: &amp;#34;Reservation at Malloys&amp;#34;, &amp;#34;completed&amp;#34;: true, &amp;#34;userId&amp;#34;: 1 }, // .</description></item><item><title>Repositories</title><link>/docs/repositories/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/repositories/</guid><description>Flutter Data is organized around the concept of models which are data classes extending DataModel.
@DataRepository([TaskAdapter]) class Task extends DataModel&amp;lt;Task&amp;gt; { @override final int? id; final String title; final bool completed; Task({this.id, required this.title, this.completed = false}); // ... } When annotated with @DataRepository (and adapters as arguments, as we&amp;rsquo;ll see later) a model gets its own fully-fledged repository.
Repository is the API used to interact with models, whether local or remote.</description></item><item><title>Marking tasks as done</title><link>/tutorial/updating/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/updating/</guid><description>A read-only tasks app is not very practical! Let&amp;rsquo;s add the ability to update the completed state and mark/unmark our tasks as done.
First, though, we&amp;rsquo;ll extract the tasks-specific code to a separate screen named TasksScreen:
class TasksScreen extends HookConsumerWidget { @override Widget build(BuildContext context, WidgetRef ref) { final state = ref.tasks.watchAll(); if (state.isLoading) { return CircularProgressIndicator(); } return ListView( children: [ for (final task in state.model!) Text(task.title), ], ); } } Remember to return this new widget from TasksApp:</description></item><item><title>Adapters</title><link>/docs/adapters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/adapters/</guid><description>Flutter Data&amp;rsquo;s building blocks are called adapters, making it extremely customizable and composable.
Adapters are essentially Dart mixins applied on RemoteAdapter&amp;lt;T&amp;gt;.
Overriding basic behavior Several pieces of information are required, for example, to construct a remote findAll call on a Repository&amp;lt;Task&amp;gt;. The framework takes a sensible guess and makes that GET /tasks by default.
Still, a base URL is necessary and the endpoint parts should be overridable.
The way we use these adapters is by declaring them on our @DataRepository annotation in the corresponding model.</description></item><item><title>Creating a new task</title><link>/tutorial/creating/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/creating/</guid><description>First off let&amp;rsquo;s add just one line during the initialization. This will enable very helpful logging of our tasks repository!
// ... child: ref.watch(repositoryInitializerProvider).when( error: (error, _) =&amp;gt; Text(error.toString()), loading: () =&amp;gt; const CircularProgressIndicator(), data: (_) { // enable verbose ref.tasks.logLevel = 2; return TasksScreen(); } ), // ... When we restart we notice the following:
flutter: 34:061 [watchAll/tasks@e20025] initializing flutter: 34:100 [findAll/tasks@e2046b&amp;lt;e20025] requesting [HTTP GET] https://my-json-server.typicode.com/flutterdata/demo/tasks flutter: 34:835 [findAll/tasks@e2046b&amp;lt;e20025] {1, 2, 3, 4, 5} (and 5 more) fetched from remote Let&amp;rsquo;s add a TextField, turn the input into a new Task and immediately save it.</description></item><item><title>Local Adapters</title><link>/docs/local-adapters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/local-adapters/</guid><description>Local adapters access the local storage, which for now is only Hive.
It is extremely rare to have to override a local adapter, so use with caution if you do.
A particularly useful use-case is data migration as LocalAdapter&amp;rsquo;s deserialize will be called after loading raw data from the Hive box and before the json_serializable call.
Example:
mixin TaskLocalAdapter on LocalAdapter&amp;lt;Task&amp;gt; { @override Task deserialize(Map&amp;lt;String, dynamic&amp;gt; map) { // transform map from old format to new format } } Activate the use of the overridden adapter with:</description></item><item><title>Models</title><link>/docs/models/</link><pubDate>Mon, 20 Apr 2020 19:01:08 -0300</pubDate><guid>/docs/models/</guid><description>Flutter Data models are data classes that extend DataModel and are annotated with @DataRepository:
@DataRepository([TaskAdapter]) @JsonSerializable() class Task extends DataModel&amp;lt;Task&amp;gt; { @override final int? id; final String title; final bool completed; Task({this.id, required this.title, this.completed = false}); } DataModel automatically registers new data classes within the framework and enforces the implementation of an id getter. Use the type that better suits you: int? and String? are the most common.
The json_serializable library is helpful but not required.</description></item><item><title>Reloading the list</title><link>/tutorial/reloading/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/reloading/</guid><description>Let&amp;rsquo;s make the number of tasks more manageable via the _limit server query param, which in this case will return a maximum of 5 resources.
class TasksScreen extends HookConsumerWidget { @override Widget build(BuildContext context, WidgetRef ref) { final state = ref.tasks.watchAll(params: {&amp;#39;_limit&amp;#39;: 5}); // ... } Hot restarting the app we should only see five tasks, but&amp;hellip;
It&amp;rsquo;s exactly the same as before. Why isn&amp;rsquo;t this working? ðŸ¤”
Turns out watchAll is wired to show all tasks in local storage.</description></item><item><title>Relationships</title><link>/docs/relationships/</link><pubDate>Mon, 20 Apr 2020 17:21:33 -0300</pubDate><guid>/docs/relationships/</guid><description>Flutter Data features an advanced relationship mapping system.
Use:
HasMany&amp;lt;T&amp;gt; for to-many relationships BelongsTo&amp;lt;T&amp;gt; for to-one relationships As an example, a User has many Tasks:
@JsonSerializable() @DataRepository([JsonServerAdapter]) class User extends DataModel&amp;lt;User&amp;gt; { @override final int? id; final String name; final HasMany&amp;lt;Task&amp;gt;? tasks; User({this.id, required this.name, this.tasks}); } and a Task belongs to a User:
@JsonSerializable() @DataRepository([JsonServerAdapter]) class Task extends DataModel&amp;lt;Task&amp;gt; { @override final int? id; final String title; final bool completed; final BelongsTo&amp;lt;User&amp;gt;?</description></item><item><title>Deleting tasks</title><link>/tutorial/deleting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/deleting/</guid><description>There&amp;rsquo;s stuff we just don&amp;rsquo;t want to do!
We can delete a Task on dismiss by wrapping the tile with a Dismissible and calling its delete method:
class TasksScreen extends HookConsumerWidget { @override Widget build(BuildContext context, WidgetRef ref) { final _newTaskController = useTextEditingController(); final state = ref.tasks.watchAll(params: {&amp;#39;_limit&amp;#39;: 5}, syncLocal: true); if (state.isLoading) { return CircularProgressIndicator(); } return RefreshIndicator( onRefresh: () =&amp;gt; ref.tasks.findAll(params: {&amp;#39;_limit&amp;#39;: 5}, syncLocal: true), child: ListView( children: [ TextField( controller: _newTaskController, onSubmitted: (value) async { Task(title: value).</description></item><item><title>Offline</title><link>/docs/offline/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/offline/</guid><description>You can do this in your Scaffold
child: ref.watch(initializerProvider).when( error: (error, _) =&amp;gt; Text(error.toString()), loading: () =&amp;gt; const CircularProgressIndicator(), data: (_) =&amp;gt; Text(&amp;#39;App boot is ready, replace me with main UI widget&amp;#39;), ), ), Then define your initializer where you initialize any number of services needed to display the main widget of your UI:
final initializerProvider = FutureProvider&amp;lt;void&amp;gt;((ref) async { // initialize FD await ref.container.refresh(repositoryInitializerProvider.future); // initialize other services // retry offline events final _sub = ref.</description></item><item><title>Initialization</title><link>/docs/initialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/initialization/</guid><description>Initializing Flutter Data consists of two parts: local storage initialization and repository initialization.
The former happens when wiring up providers and the latter during widget build.
Local storage initialization Here are the configuration options with their default arguments explicit:
ProviderScope( child: MyApp(), overrides: [ configureRepositoryLocalStorage( // callback that returns a base directory where to place local storage // (if the path_provider package is present, otherwise you MUST override it) baseDirFn: () =&amp;gt; getApplicationDocumentsDirectory().</description></item><item><title>FAQ</title><link>/docs/faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/faq/</guid><description>Why are save and other methods not available on my models? DataModel extensions are syntax sugar and will only work when importing Flutter Data:
import &amp;#39;package:flutter_data/flutter_data.dart&amp;#39;; Errors generating code? If you have trouble with the outputs, try:
flutter pub run build_runner build --delete-conflicting-outputs VSCode users!
If after generating code you still see errors in your files, try reopening the project. This is not a Flutter Data issue.
Also make sure your dependencies are up to date:</description></item><item><title>Using relationships</title><link>/tutorial/relationships/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/relationships/</guid><description>Let&amp;rsquo;s now slightly rethink our query. Instead of &amp;ldquo;fetching all tasks for user 1&amp;rdquo; we are going to &amp;ldquo;fetch user 1 with all their tasks&amp;rdquo;.
Flutter Data has first-class support for relationships.
First, in models/user.dart, we&amp;rsquo;ll create the User model with a HasMany&amp;lt;Task&amp;gt; relationship:
import &amp;#39;package:flutter_data/flutter_data.dart&amp;#39;; import &amp;#39;package:json_annotation/json_annotation.dart&amp;#39;; import &amp;#39;task.dart&amp;#39;; part &amp;#39;user.g.dart&amp;#39;; @JsonSerializable() @DataRepository([JsonServerAdapter]) class User extends DataModel&amp;lt;User&amp;gt; { @override final int? id; final String name; final HasMany&amp;lt;Task&amp;gt; tasks; User({this.id, required this.</description></item><item><title>How to Reinitialize Flutter Data</title><link>/articles/how-to-reinitialize-flutter-data/</link><pubDate>Sat, 18 Dec 2021 17:08:28 -0300</pubDate><guid>/articles/how-to-reinitialize-flutter-data/</guid><description>By calling repositoryInitializerProvider again with Riverpod&amp;rsquo;s refresh we can reinitialize Flutter Data.
class TasksApp extends HookConsumerWidget { @override Widget build(BuildContext context, WidgetRef ref) { return MaterialApp( home: RefreshIndicator( onRefresh: () async =&amp;gt; ref.container.refresh(repositoryInitializerProvider.future), child: Scaffold( body: Center( child: ref.watch(repositoryInitializerProvider).when( error: (error, _) =&amp;gt; Text(error.toString()), loading: () =&amp;gt; const CircularProgressIndicator(), data: (_) =&amp;gt; TasksScreen(), ), ), ), ), ); } }</description></item><item><title>Nested Resources Adapter</title><link>/articles/nested-resources-adapter/</link><pubDate>Thu, 09 Dec 2021 23:17:30 -0300</pubDate><guid>/articles/nested-resources-adapter/</guid><description>Here&amp;rsquo;s how you could access nested resources such as: /posts/1/comments
mixin NestedURLAdapter on RemoteAdapter&amp;lt;Comment&amp;gt; { // ... @override String urlForFindAll(params) =&amp;gt; &amp;#39;/posts/${params[&amp;#39;postId&amp;#39;]}/comments&amp;#39;; // or even @override String urlForFindAll(params) { final postId = params[&amp;#39;postId&amp;#39;]; if (postId != null) { return &amp;#39;/posts/${params[&amp;#39;postId&amp;#39;]}/comments&amp;#39;; } return super.urlForFindAll(params); } } and call it like:
final comments = await commentRepository.findAll(params: {&amp;#39;postId&amp;#39;: post.id });</description></item><item><title>Custom Deserialization Adapter</title><link>/articles/custom-deserialization-adapter/</link><pubDate>Thu, 09 Dec 2021 23:15:44 -0300</pubDate><guid>/articles/custom-deserialization-adapter/</guid><description>Example:
mixin AuthAdapter on RemoteAdapter&amp;lt;User&amp;gt; { Future&amp;lt;String&amp;gt; login(String email, String password) async { return sendRequest( baseUrl.asUri / &amp;#39;token&amp;#39;, method: DataRequestMethod.POST, body: json.encode({&amp;#39;email&amp;#39;: email, &amp;#39;password&amp;#39;: password}), onSuccess: (data) =&amp;gt; data[&amp;#39;token&amp;#39;] as String, ); } } and use it:
final token = await userRepository.authAdapter.login(&amp;#39;e@mail, p*ssword&amp;#39;); Also see JSONAPIAdapter for inspiration.</description></item><item><title>Intercept Logout Adapter</title><link>/articles/intercept-logout-adapter/</link><pubDate>Thu, 09 Dec 2021 23:15:11 -0300</pubDate><guid>/articles/intercept-logout-adapter/</guid><description>The global onError handler will call logout if certain conditions are met:
mixin BaseAdapter&amp;lt;T extends DataModel&amp;lt;T&amp;gt;&amp;gt; on RemoteAdapter&amp;lt;T&amp;gt; { @override FutureOr&amp;lt;Null?&amp;gt; onError&amp;lt;Null&amp;gt;(DataException e) async { // Automatically logout user if a 401/403 is returned from any API response. if (e.statusCode == 401 || e.statusCode == 403) { await read(sessionProvider).logOut(); return null; } throw e; } }</description></item><item><title>Override findAll Adapter</title><link>/articles/override-findall-adapter/</link><pubDate>Thu, 09 Dec 2021 23:14:28 -0300</pubDate><guid>/articles/override-findall-adapter/</guid><description>In this example we completely override findAll to return random models:
mixin FindAllAdapter&amp;lt;T extends DataModel&amp;lt;T&amp;gt;&amp;gt; on RemoteAdapter&amp;lt;T&amp;gt; { @override Future&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; findAll({ bool? remote, Map&amp;lt;String, dynamic&amp;gt;? params, Map&amp;lt;String, String&amp;gt;? headers, bool? syncLocal, OnDataError&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;? onError, }) async { // could use: super.findAll(); return _generateRandomModels&amp;lt;T&amp;gt;(); } }</description></item><item><title>Override findOne URL Adapter</title><link>/articles/override-findone-url-method/</link><pubDate>Thu, 09 Dec 2021 23:14:28 -0300</pubDate><guid>/articles/override-findone-url-method/</guid><description>In this example we override URLs to hit finder endpoints with snake case, and for save to always use HTTP PUT:
mixin URLAdapter&amp;lt;T extends DataModel&amp;lt;T&amp;gt;&amp;gt; on RemoteAdapter&amp;lt;T&amp;gt; { @override String urlForFindAll(Map&amp;lt;String, dynamic&amp;gt; params) =&amp;gt; type.snakeCase; @override String urlForFindOne(id, Map&amp;lt;String, dynamic&amp;gt; params) =&amp;gt; &amp;#39;${type.snakeCase}/$id&amp;#39;; @override DataRequestMethod methodForSave(id, Map&amp;lt;String, dynamic&amp;gt; params) { return DataRequestMethod.PUT; } }</description></item><item><title>Iterator Style Adapter</title><link>/articles/iterator-style-adapter/</link><pubDate>Thu, 09 Dec 2021 23:13:36 -0300</pubDate><guid>/articles/iterator-style-adapter/</guid><description>mixin AppointmentAdapter on RemoteAdapter&amp;lt;Appointment&amp;gt; { Future&amp;lt;Appointment?&amp;gt; fetchNext() async { return await sendRequest( baseUrl.asUri / type / &amp;#39;next&amp;#39;, onSuccess: (data) =&amp;gt; deserialize(data).model, ); } } Using sendRequest we have both fine-grained control over our request while leveraging existing adapter features such as type, baseUrl, deserialize and any other customizations.
Adapters are applied on RemoteAdapter but Flutter Data will automatically create shortcuts to call these custom methods.
final nextAppointment = await appointmentRepository.appointmentAdapter.fetchNext();</description></item><item><title>Override HTTP Client Adapter</title><link>/articles/override-http-client-adapter/</link><pubDate>Thu, 09 Dec 2021 23:10:10 -0300</pubDate><guid>/articles/override-http-client-adapter/</guid><description>An example on how to override and use a more advanced HTTP client.
Here the connectionTimeout is increased, and an HTTP proxy enabled.
mixin HttpProxyAdapter&amp;lt;T extends DataModel&amp;lt;T&amp;gt;&amp;gt; on RemoteAdapter&amp;lt;T&amp;gt; { HttpClient? _httpClient; IOClient? _ioClient; @override http.Client get httpClient { _httpClient ??= HttpClient(); _ioClient ??= IOClient(_httpClient); // increasing the timeout _httpClient!.connectionTimeout = const Duration(seconds: 5); // using a proxy _httpClient!.badCertificateCallback = ((X509Certificate cert, String host, int port) =&amp;gt; true); _httpClient!.findProxy = (uri) =&amp;gt; &amp;#39;PROXY (proxy url)&amp;#39;; return _ioClient!</description></item><item><title>Override Default Headers and Query Parameters</title><link>/articles/override-headers-query-parameters/</link><pubDate>Thu, 09 Dec 2021 23:07:40 -0300</pubDate><guid>/articles/override-headers-query-parameters/</guid><description>Custom headers and query parameters can be passed into all finders and watchers (findAll, findOne, save, watchOne etc) but sometimes defaults are necessary.
Here is how:
mixin BaseAdapter&amp;lt;T extends DataModel&amp;lt;T&amp;gt;&amp;gt; on RemoteAdapter&amp;lt;T&amp;gt; { final _localStorageService = read(localStorageProvider); @override String get baseUrl =&amp;gt; &amp;#34;http://my.remote.url:8080/&amp;#34;; @override FutureOr&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; get defaultHeaders async { final token = _localStorageService.getToken(); return await super.defaultHeaders &amp;amp; {&amp;#39;Authorization&amp;#39;: token}; } @override FutureOr&amp;lt;Map&amp;lt;String, dynamic&amp;gt;&amp;gt; get defaultParams async { return await super.</description></item><item><title>Configure Flutter Data to Work with GetIt</title><link>/articles/configure-get-it/</link><pubDate>Sun, 05 Dec 2021 23:12:05 -0300</pubDate><guid>/articles/configure-get-it/</guid><description>This is an example of how we can configure Flutter Data to use GetIt as a dependency injection framework.
Important: Make sure to replicate ProxyProviders for other models than Todo.
class GetItTodoApp extends StatelessWidget { @override Widget build(context) { GetIt.instance.registerRepositories(); return MaterialApp( home: Scaffold( body: Center( child: FutureBuilder( future: GetIt.instance.allReady(), builder: (context, snapshot) { if (!snapshot.hasData) { return const CircularProgressIndicator(); } final repository = GetIt.instance.get&amp;lt;Repository&amp;lt;Todo&amp;gt;&amp;gt;(); return GestureDetector( onDoubleTap: () async { print((await repository.</description></item><item><title>Configure Flutter Data to Work with Provider</title><link>/articles/configure-provider/</link><pubDate>Sun, 05 Dec 2021 23:12:05 -0300</pubDate><guid>/articles/configure-provider/</guid><description>This is an example of how we can configure Flutter Data to use Provider as a dependency injection framework.
Important: Make sure to replicate ProxyProviders for other models than Todo.
class ProviderTodoApp extends StatelessWidget { @override Widget build(context) { return MultiProvider( providers: [ ...providers(clear: true), ProxyProvider&amp;lt;Repository&amp;lt;Todo&amp;gt;?, SessionService?&amp;gt;( lazy: false, create: (_) =&amp;gt; SessionService(), update: (context, repository, service) { if (service != null &amp;amp;&amp;amp; repository != null) { return service..initialize(repository); } return service; }, ), ], child: MaterialApp( home: Scaffold( body: Center( child: Builder( builder: (context) { if (context.</description></item><item><title>Override Base URL Adapter</title><link>/articles/override-base-url/</link><pubDate>Fri, 03 Dec 2021 18:45:45 -0300</pubDate><guid>/articles/override-base-url/</guid><description>Flutter Data is extended via adapters.
mixin UserURLAdapter on RemoteAdapter&amp;lt;User&amp;gt; { @override String get baseUrl =&amp;gt; &amp;#39;https://my-json-server.typicode.com/flutterdata/demo&amp;#39;; } Need to apply the adapter to all your models? Make it generic:
mixin UserURLAdapter&amp;lt;T extends DataModel&amp;lt;T&amp;gt;&amp;gt; on RemoteAdapter&amp;lt;T&amp;gt; { @override String get baseUrl =&amp;gt; &amp;#39;https://my-json-server.typicode.com/flutterdata/demo&amp;#39;; }</description></item><item><title>Deconstructing Dart Constructors</title><link>/articles/deconstructing-dart-constructors/</link><pubDate>Wed, 12 Feb 2020 13:43:48 -0500</pubDate><guid>/articles/deconstructing-dart-constructors/</guid><description>Ever confused by that mysterious syntax in Dart constructors? Colons, named parameters, asserts, factories&amp;hellip;
Read this post and you will become an expert!
When we want an instance of a certain class we call a constructor, right?
var robot = new Robot(); In Dart 2 we can leave out the new:
var robot = Robot(); A constructor is used to ensure instances are created in a coherent state. This is the definition in a class:</description></item><item><title>Dart Getter Shorthand to Cache Computed Properties</title><link>/articles/dart-getter-cache-computed-properties/</link><pubDate>Sat, 04 Jan 2020 13:43:48 -0500</pubDate><guid>/articles/dart-getter-cache-computed-properties/</guid><description>An elegant Dart getter shorthand used to cache computed properties:
T get foo =&amp;gt; _foo ??= _computeFoo(); // which depends on having T _foo; T _computeFoo() =&amp;gt; /** ... **/; It makes use of the fallback assignment operator ??=.
Check out Null-Aware Operators in Dart for a complete guide on dealing with nulls in Dart!</description></item><item><title>Final vs const in Dart</title><link>/articles/dart-final-const-difference/</link><pubDate>Sat, 04 Jan 2020 13:43:48 -0500</pubDate><guid>/articles/dart-final-const-difference/</guid><description>What&amp;rsquo;s the difference between final and const in Dart?
Easy!
Final means single-assignment.
Const means immutable.
Let&amp;rsquo;s see an example:
final _final = [2, 3]; const _const = [2, 3]; _final = [4,5]; // ERROR: can&amp;#39;t re-assign _final.add(6); // OK: can mutate _const.add(6); // ERROR: can&amp;#39;t mutate Want to know EVERYTHING about Dart constructors? Check out Deconstructing Dart Constructors!</description></item><item><title>How To Define an Interface in Dart</title><link>/articles/define-interface-dart/</link><pubDate>Sat, 04 Jan 2020 13:43:48 -0500</pubDate><guid>/articles/define-interface-dart/</guid><description>Dart defines implicit interfaces. What does this mean?
In your app you&amp;rsquo;d have:
class Session { authenticate() { // impl } } or
abstract class Session { authenticate(); } And for example in tests:
class MockSession implements Session { authenticate() { // mock impl } } No need to define a separate interface, just use regular or abstract classes!
Want to know EVERYTHING about Dart constructors? Check out Deconstructing Dart Constructors!</description></item><item><title>How to Build Widgets with an Async Method Call</title><link>/articles/build-widget-with-async-method-call/</link><pubDate>Wed, 18 Dec 2019 00:00:00 +0000</pubDate><guid>/articles/build-widget-with-async-method-call/</guid><description>You want to return a widget in a build method&amp;hellip;
But your data comes from an async function!
class MyWidget extends StatelessWidget { @override Widget build(context) { callAsyncFetch().then((data) { return Text(data); // doesn&amp;#39;t work }); } } The callAsyncFetch function could be an HTTP call, a Firebase call, or a call to SharedPreferences or SQLite, etc. Anything that returns a Future ðŸ”®.
So, can we make the build method async? ðŸ¤”</description></item><item><title>Why Is My Future/Async Called Multiple Times?</title><link>/articles/future-async-called-multiple-times/</link><pubDate>Wed, 18 Dec 2019 00:00:00 +0000</pubDate><guid>/articles/future-async-called-multiple-times/</guid><description>Why is FutureBuilder firing multiple times? My future should be called just once!
It appears that this build method is rebuilding unnecessarily:
@override Widget build(context) { return FutureBuilder&amp;lt;String&amp;gt;( future: callAsyncFetch(), // called all the time!!! ðŸ˜¡ builder: (context, snapshot) { // rebuilding all the time!!! ðŸ˜¡ } ); } This causes unintentional network refetches, recomputes and rebuilds â€“ which can also be an expensive problem if using Firebase, for example.</description></item><item><title>The Ultimate Javascript vs Dart Syntax Guide</title><link>/articles/ultimate-javascript-dart-syntax-guide/</link><pubDate>Tue, 15 Oct 2019 13:43:48 -0500</pubDate><guid>/articles/ultimate-javascript-dart-syntax-guide/</guid><description>Nowadays, Dart is almost only used in the context of Flutter. This guide is exclusively focused in comparing Javascript and Dart&amp;rsquo;s syntax.
(Pros and cons of choosing Flutter/Dart is outside the scope of this article.)
So if you have a JS background and want to build apps with this awesome framework, read on. Letâ€™s see how these two puppies fair against each other!
Variables and constants // js var dog1 = &amp;#34;Lucy&amp;#34;; // variable let dog2 = &amp;#34;Milo&amp;#34;; // block scoped variable const maleDogs = [&amp;#34;Max&amp;#34;, &amp;#34;Bella&amp;#34;]; // mutable single-assignment variable maleDogs.</description></item><item><title>Checking Nulls and Null-Aware Operators in Dart</title><link>/articles/checking-null-aware-operators-dart/</link><pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate><guid>/articles/checking-null-aware-operators-dart/</guid><description>What is the best practice for checking nulls in Dart?
var value = maybeSomeNumber(); if (value != null) { doSomething(); } That&amp;rsquo;s right. There is no shortcut like if (value) and truthy/falsey values in Javascript. Conditionals in Dart only accept bool values.
However! There are some very interesting null-aware operators.
Default operator: ?? In other languages we can use the logical-or shortcut. If maybeSomeNumber() returns null, assign a default value of 2:</description></item><item><title>How to Format a Duration as a HH:MM:SS String</title><link>/articles/how-to-format-duration/</link><pubDate>Tue, 10 Sep 2019 23:43:48 -0500</pubDate><guid>/articles/how-to-format-duration/</guid><description>The shortest, most elegant and reliable way to get HH:mm:ss from a Duration is doing:
format(Duration d) =&amp;gt; d.toString().split(&amp;#39;.&amp;#39;).first.padLeft(8, &amp;#34;0&amp;#34;); Example usage:
main() { final d1 = Duration(hours: 17, minutes: 3); final d2 = Duration(hours: 9, minutes: 2, seconds: 26); final d3 = Duration(milliseconds: 0); print(format(d1)); // 17:03:00 print(format(d2)); // 09:02:26 print(format(d3)); // 00:00:00 } If we are dealing with smaller durations and needed only minutes and seconds:
format(Duration d) =&amp;gt; d.</description></item><item><title>How to Upgrade Flutter</title><link>/articles/upgrade-flutter-sdk/</link><pubDate>Tue, 27 Aug 2019 12:43:48 -0500</pubDate><guid>/articles/upgrade-flutter-sdk/</guid><description>Type in your terminal:
flutter upgrade This will update Flutter to the latest version in the current channel. Most likely you have it set in stable.
flutter channel # Flutter channels: # beta # dev # master # * stable Do you want to live in the cutting edge? Switching channels is easy:
flutter channel dev # Switching to flutter channel &amp;#39;dev&amp;#39;... # ... And run upgrade again:
flutter upgrade</description></item><item><title>Minimal Flutter Apps to Get Started</title><link>/articles/minimal-hello-world-flutter-app/</link><pubDate>Tue, 30 Jul 2019 23:43:48 -0500</pubDate><guid>/articles/minimal-hello-world-flutter-app/</guid><description>Every time I do a flutter create project I get the default &amp;ldquo;counter&amp;rdquo; sample app full of comments.
While it&amp;rsquo;s great for the very first time, I now want to get up and running with a minimal base app that fits in my screen.
Here are a few options to copy-paste into lib/main.dart.
Bare bones app // lib/main.dart import &amp;#39;package:flutter/widgets.dart&amp;#39;; main() =&amp;gt; runApp(MyApp()); class MyApp extends StatelessWidget { @override Widget build(context) =&amp;gt; Center( child: Text(&amp;#39;Hello Flutter!</description></item></channel></rss>